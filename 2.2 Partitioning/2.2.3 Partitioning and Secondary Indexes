A secondary index doesn't identify a record uniquely but rather is a way of searching for occurrences of a particular value. They are critical in RDBMS. KV stores such as HBase and Voldemort have avoided secondary indexes due to added implementation complexity, but some like Riak have started adding them due to usefulness in data modeling. They are very important for search servers such as Solr and ElasticSearch. Problem with secondary indexes is that they don't map neatly to partitions.

Partitioning Secondary Indexes by Document - Imagine a website with some listings and each listing has a unique document ID, and partitioning is based on this document ID. If it's a car we need to add secondary indexes on color and make (these are fields in document DBs and columns in RDBMS). If index is declared, the database can perform the indexing automatically. Whenever a 'red' car is added to the db, the db partition can automatically add it to the list of documents IDs for the index 'color:red'. In this case, each partition is completely separate - maintains its own secondary indexes covering documents only in that partition. Doesn't care what data is stored in other partitions. When read/write needs to be done, we only deal with one partition with the document ID. Hence, document-partitioned index is called "Local Index".
While reading from document-partitioned index, there is no reason why all red cars are in same partition (unless Document ID is somehow modified). So, reads should be done across all partitions and results combined. This approach is called "Scatter/Gather" and queries on secondary index will be expensive (even when parallelized - tail latency amplification). DB vendors suggest to structure the document-partitioned secondary index such that queries on secondary index can be handled by single partition. But this is difficult, especially when queries are against more than one secondary index. [Used in MongoDB, Riak, Cassandra, elasticsearch]

Partitioning Secondary Indexes by Term - Instead of each partition having its own secondary index (local index), we can have a global index which covers data in all partitions. This index has to be partitioned as well, since storing it on one node makes it a bottleneck and defeats the purpose of partitioning. Ex. red cars from all partitions appear under color:red in index, but the index is partitioned so that all colors starting with a to r are on one partition, and s to z are on another partition.
This index is called "Term-Partitioned" because the term we are looking for determines the partition of the index. "Term" refers to full-text indexes (which are secondary indexes), where terms are the words in a document. Partitioning can use the term or it's hash - range scan vs. even load distribution. Advantage of global index over document-partitioned index is that reads are more efficient - instead of doing scatter/gather over all partitions, client makes a request to the partition which contains required term. Disadvantage is that writes are slower and more complex - write to a single document may affect different partitions of index (terms maybe on different partitions and diff nodes)
Ideally, indexes should remain up-to-date and every document written should be reflect imm in the index - but here this requires a distributed transaction acros all partitions affected by a write. Usually updates to secondary indexes are asynchronous (reading after a short while will not access required up-to-date index)
