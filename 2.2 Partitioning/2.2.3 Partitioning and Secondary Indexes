A secondary index doesn't identify a record uniquely but rather is a way of searching for occurrences of a particular value. They are critical in RDBMS. KV stores such as HBase and Voldemort have avoided secondary indexes due to added implementation complexity, but some like Riak have started adding them due to usefulness in data modeling. They are very important for search servers such as Solr and ElasticSearch. Problem with secondary indexes is that they don't map neatly to partitions.

Partitioning Secondary Indexes by Document - Imagine a website with some listings and each listing has a unique document ID, and partitioning is based on this document ID. If it's a car we need to add secondary indexes on color and make (these are fields in document DBs and columns in RDBMS). If index is declared, the database can perform the indexing automatically. Whenever a 'red' car is added to the db, the db partition can automatically add it to the list of documents IDs for the index 'color:red'. In this case, each partition is completely separate - maintains its own secondary indexes covering documents only in that partition. Doesn't care what data is stored in other partitions. When read/write needs to be done, we only deal with one partition with the document ID. Hence, document-partitioned index is called "Local Index".
While reading from document-partitioned index, there is no reason why all red cars are in same partition (unless Document ID is somehow modified). So, reads should be done across all partitions and results combined. This approach is called "Scatter/Gather" and queries on secondary index will be expensive (even when parallelized - tail latency amplification). DB vendors suggest to structure the document-partitioned secondary index such that queries on secondary index can be handled by single partition. But this is difficult, especially when queries are against more than one secondary index. [Used in MongoDB, Riak, Cassandra, elasticsearch]

Partitioning Secondary Indexes by Term - 
