Concurrency issues come into play when two trans try to simultaneously modify the same data, or when one transaction reads data concurrently being written by another transaction. Bugs are hard to find by testing because such bugs are only triggered when you get unlucky with timing. Such timing issues are diff to reproduce as they occur rarely. Also, in large appl we don't know which piece of code is accessing the DBs. Having many conc users makes it harder because any data can change unexpectedly at any time. 
So DBs try to hide conc issues using trans isolation. In theory, we pretend no concurrency - serializable isolation. DB makes it look like two conc operations are actually running serially. But serializable isolation has perf cost and most DB don't implement - but rather use weaker levels of isolation which protect against some concurrency issues not all. These levels of isolation are harder to understand and leads to subtle bugs
Understanding conc issues properly and how to solve them is required to build apps that are reliable and correct, using tools at disposal. Diff kinds of race conditions can and can't occur at diff levels of isolation - then we can decide which level is approp for our system

Read Committed
Most basic level of trans isolation and makes two guarantees - When reading from DB, we will only see data that is committed "NO DIRTY READS" and when writing to DB, we will only overwrite data that is committed "NO DIRTY WRITES"

1. No Dirty Reads - In a case where trans has writted some data to DB but trans has not yet committed or aborted, if another trans can see that uncommitted data then that read is called a dirty read. This isolation level must prevent dirty reads - any writes by a trans becomes visible to others only when the trans commits. Useful to prevent dirty reads because:
a. If a trans needs to update several object, dirty reads shows only some updates. Seeing DB in partially updated state is confusing to users and also leads to other transactions taking incorrect decisions
b. If a trans aborts, any writes made need to be rolled back. Dirty reads show data that will be rolled back later, never committed

2. No Dirty Writes - When two trans conc update same objecet in DB, we don't know which order writes will happen in, but normally assume that later write overwrites the earlier write. If earlier write is part of uncommitted trans, later write will overwrite an uncommitted value - this is called dirty write. Trans running at read committed isolation level, must prevent dirty writes, and this is done by delaying later write till earlier write trans is committed or aborted. It avoid some problems:
a. If trans updates multiple objects, dirty writes can lead to incorrect outcome - car is sold to one person but invoice is sent to a diff person
b. In case of read-update-write, this isolation prevents dirty writes (although outcome is incorrect still)

Implementing Read Committed - 
