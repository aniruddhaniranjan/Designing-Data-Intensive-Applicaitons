Read-Scaling Architecture - For workloads which are read-heavy and consists of small percentage of writes (common pattern in web applications), one good option is to create many followers and distribute read requests across these. Removes load from leader and decreases latency. You can increase read handling capacity by adding more followers. But replication works well here only if asynchronously done (otherwise one follower going down will stop the entire system).
Drawback in async replication is follower falling behind the leader in processing writes - leads to inconsistency in database (same read against leader and follower gives different results). Lag can range from fraction of a second to several minutes (when system is at near capacity). But when all writes are stopped temporarily, followers catch up - Eventual Consistency. The main issues with replication lag are as follows:

1. Reading Your Own Writes
When new data is submitted, it is sent to leader. But when data is read, it can be read from follower (Data is frequently viewed but only occasionally written). In async replication, if the data is read shortly after being written, it might not yet have reached a follower - it appears that the data written by user was lost. So we need "Read-After-Write Consistency" or "Read-Your-Writes Consistency". It assures the user that their own input has been saved - if user reloads the page, their own write will definitely be visible (no guarantees on writes from other users).
a. When reading something a user might have modified, read it only from leader (need to know if it's info user might have modified without querying - one type of such info is user profile info on a site)
b. Use other criteria when most info can be modified by user - for one minute since last write, read only from the leader or monitor repl. lag on follower and avoid reading from a follower which is more than a minute behind
c. Client can remember timestamp of it's most recent write - use followers which serve data upto this timestamp. If a replica is behind delay the read until it catches up to this time

* If replicas are distributed geographically, read to a leader must be routed to appropriate datacenter
If user uses multiple devices, the "Cross-Device Read-After-Write Consistency" must be provided. Additional issues here are:
a. If timestamp of last update is used, then this metadata has to be centralized - code on one device doesn't know what updates happened on another device
b. If replicas are in different datacenters (home wifi vs mobile cellular network), reading from leader must first route all requests from all devices to the leader's datacenter

2. Monotonic Reads
User can make the same read requests to different replicas, one with small lag and one with large lag. If the replica with small lag has picked up some data updates which the other replica hasn't, then the user will appear to see things "Moving Backwards in Time". This is possible when there are events like browser refresh which are routed to different replicas. (The situation would be slightly better if none of these replicas have picked up a data change). "Monotonic Reads" is a guarantee which means when a user makes several reads in sequence they will not see time moving backwards - newer data followed by older data. It is not as good as strong consistency but better than eventual consistency. One way to do this is have a user always read from the same replica (but some failover is needed) - hash of userID can be mapped to a replica.

3. Consistent Prefix Reads
There can be a sequence of messages or updates that are causally related. It could happen that one message goes through a follower with large lag and a later message goes through a follower with lower lag. In this case, a user who reads these messages can see them out of order. "Consistent Prefix Reads" prevent this form of anomaly - if a sequence of writes happen in a certain order, then anyone reading them will see them appear in the same order. This is a common problem in sharded/partitioned DBs where the different partitions operate independently. There is no global ordering of writes - so some parts of the DB might be in an older state than other parts. One solution is to write causally related messages into the same partition.

Solutions for Replication Lag
Replication lag can increase to several minutes or few hours - if this causes bad user experience, then strong guarantees such as read-after-write must be provided. Application can provide some guarantess - such as making certain reads only with leader. But adding these guarantees in application code is complex and error-prone. Transactions take this responsibility away from application code - but it is great only for single node and not distributed systems. They are too expensive in terms of performance and availability.
